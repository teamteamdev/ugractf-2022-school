# Крестики-нолики: Write-up

Запускаем пробную версию игры. После прочтённого предупреждения об урезанных возможностях заходим в игру и играем пробную партию. Выясняем, что играть получится только за нолики.

Попытки проанализировать исполняемый файл далеко не приведут -- всё приложение написано на Haskell, языке программирования, плохо поддающимся декомпиляции. Однако игра, как заявлено, сетевая, и можно изучить протокол взаимодействия с сервером.

Запустим Wireshark и клиент игры. Первое сообщение от клиента серверу выглядит так:

```
0000   00 00 00 00 00 00 cc 13 22 00 00 00 00 00 00 00   ........".......
0010   64                                                d
```

К сожалению, протокол обмена с сервером -- бинарный, и не сразу получится разобраться в смысле сообщений. В таких случаях протокол можно анализировать, запуская клиент много раз и выполняя различные действия. Таким образом можно заметить, каким сообщениям соответствуют команды от клиента, и где в них хранятся параметры.

Первое сообщение остаётся одинаковым при каждом подключении -- предположим, что это некоторое приветствие (_handshake_). На него сервер отвечает таким же сообщениям -- во многих протоколах в таких приветствиях содержатся версии клиента и сервера, что позволяет им договориться об "общем языке".

Следующее сообщение от клиента:

```
0000   01 00 09 74 72 69 61 6c 5f 6b 65 79               ...trial_key
```

Видим, что здесь передаётся текстом некий ключ длиной 9 символов. Сразу перед ним видим байт `09` -- скорее всего, это длина строки.

Сервер отвечает:

```
0000   02                                                .
```

Видимо, подтверждая лицензию, и сразу после этого:

```
0000   08 00 1f d0 94 d0 be d0 b1 d1 80 d0 be 20 d0 bf   ............. ..
0010   d0 be d0 b6 d0 b0 d0 bb d0 be d0 b2 d0 b0 d1 82   ................
0020   d1 8c                                             ..
```

После этого клиент показывает приглашение ("Добро пожаловать") и предлагает ввести команду.

Попробуем сыграть за крестики: `new X`. На экране появляется ошибка, а новых сообщений не передаётся. Делаем вывод, что на стороне клиента функция игры за крестики отключена полностью.

Если же выбрать нолики (`new O`), то клиент посылает сообщение:

```
0000   05 01                                             ..
```

На что сервер отвечает:

```
0000   06 01 01                                          ...
```

И затем сразу:

```
0000   08 00 26 d0 a2 d0 b5 d0 ba d1 83 d1 89 d0 b0 d1   ..&.............
0010   8f 20 d0 b4 d0 be d1 81 d0 ba d0 b0 3a 0a 5f 5f   . ..........:.__
0020   5f 0a 5f 58 5f 0a 5f 5f 5f                        _._X_.___
```

На экране при этом появляются несколько сообщений:

```
Противник сделал ход: (1, 1)
Текущая доска:
___
_X_
___
```

Попробуем сопоставить сообщения от сервера консольному выводу. Поле игры в крестики-нолики -- двухмерная доска, точку на которой можно описать двумя числами от 1 до 3 (или от 0 до 2). В первом пакете мы видим байты `01 01`, которые похожи на `(1, 1)` из консольного вывода. Позже мы попробуем подтвердить эту теорию. Второе же сообщение содержит часть вывода, который был показан на экране -- текущую карту поля. Можно предположить, что в таких сообщениях содержатся строки, которые напрямую выводятся клиентом на экран. Такие текстовые строки часто кодируются UTF-8 -- проверим эту догадку, раскодировав всё сообщение в Python:

```
>>> str = "080026d0a2d0b5d0bad183d189d0b0d18f20d0b4d0bed181d0bad0b03a0a5f5f5f0a5f585f0a5f5f5f"
>>> bytes.fromhex(str).decode("utf-8")
'\x08\x00&Текущая доска:\n___\n_X_\n___'
```

Отметим, что первый байт сообщения (`08`) мы уже встречали в сообщении раньше. Также отметим, что в сообщении после `08` идёт `00 26`. В сетевых пакетах преимущественно применяется порядок байт _big endian_, в котором старшие байты сообщения хранятся в начале. Заметим, что `26` соответствует 38 -- длине дальнейшей строки в байтах. В предыдущем сообщении после `08` шли байты `00 1f`, а затем также 31 (то есть 1f в шестнадцатеричной системе счисления) байт. Раскодируем и его:

```
>>> str = "d094d0bed0b1d180d0be20d0bfd0bed0b6d0b0d0bbd0bed0b2d0b0d182d18c"
>>> bytes.fromhex(str).decode("utf-8")
'Добро пожаловать'
```

Похоже, сообщения, начинающиеся с `08` -- это текстовые сообщения, которые необходимо вывести на экран. Они состоят из длины строки (2 байта в big endian) и самой строки. Поскольку сообщения в протоколах обычно обладают схожей структурой, можно предположить, что первый байт сообщения означает его тип. Лицензионный ключ из сообщения `01` кодировался схожим образом -- два байта размера, и затем сама строка.

Попробуем сделать ход в точку (2, 0). Клиент посылает сообщение:

```
0000   06 02 00                                          ...
```

Сравнивая с предыдущим сообщением на `06`, подтверждаем нашу догадку -- в сообщениях типа `06` передаётся ход клиента или сервера. Следующие два байта кодируют координату хода по X и Y. Сервер на это отвечает:

```
0000   06 02 01                                          ...

0000   08 00 26 d0 a2 d0 b5 d0 ba d1 83 d1 89 d0 b0 d1   ..&.............
0010   8f 20 d0 b4 d0 be d1 81 d0 ba d0 b0 3a 0a 5f 5f   . ..........:.__
0020   4f 0a 5f 58 58 0a 5f 5f 5f                        O._XX.___
```

А на экране мы видим:

```
Противник сделал ход: (2, 1)
Текущая доска:
__O
_XX
___
```

Попробуем сходить на уже занятую клетку (1, 1). Сервер отвечает:

```
0000   04 03                                             ..
```

А на экране мы видим:

```
% Ошибка: IllegalTurn
```

Что показывает нам, что сообщение `04` -- ошибка, а `03` -- возможно, её код.

Доиграем партию и посмотрим, как оканчивается игра. После очередного нашего хода компьютер занимает последнюю ячейку. После этого приходит такое сообщение:

```
0000   07 00                                             ..
```

А на экране видим:

```
Игра закончена, победитель: ничья
```

Попробуем проиграть и посмотрим, что изменится (выиграть за нолики, кажется, не получится). В конце игры получаем:

```
0000   07 01 00                                          ...
```

Похоже, сообщение `07` означает конец игры, а следующие байты кодируют победителя (пока непонятно, как).

Всей полученной информации достаточно, чтобы попробовать написать собственный клиент игры с урезанным функционалом. В первой итерации приветствие и лицензионный ключ мы отправим, как есть. Новую игру также начнём известным пакетом (за нолики), а генерировать сами будем только пакеты с текущим ходом. Такой клиент будет успешно работать!

Попробуем сыграть за крестики. В сообщении начала игры (`05`) передаётся один байт данных (`01`). Попробуем заменить его на `00`, предположив, что это код игры за крестики. Получаем сообщение:

```
0000   04 02                                             ..
```

Мы уже знаем, что `04` -- это сообщение об ошибке, но пока непонятно, в чём она заключается.

Однако, в самом задании нам был также предоставлен лицензионный ключ. Попробуем использовать его вместо найденного `trial_key`. В этом случае на запрос `05 00` сервер отвечает уже известным нам сообщением `02`, которым он также отвечал на лицензионный ключ. Попробуем сделать ход -- сервер воспринимает его, и отвечает так же, как мы наблюдали до этого!

В конце игры сервер пришлёт новое текстовое сообщение:

```
0000   08 00 80 d0 9f d0 be d0 b4 d0 b0 d1 80 d0 be d1   ................
0010   87 d0 bd d1 8b d0 b9 20 d0 ba d0 be d0 b4 20 d0   ....... ...... .
0020   bd d0 b0 20 d0 b4 d1 80 d1 83 d0 b3 d0 b8 d0 b5   ... ............
0030   20 d0 b8 d0 b3 d1 80 d1 8b 20 d0 bd d0 b0 d1 88    ........ ......
0040   d0 b5 d0 b9 20 d0 ba d0 be d0 bc d0 bf d0 b0 d0   .... ...........
0050   bd d0 b8 d0 b8 3a 20 75 67 72 61 5f 74 69 63 5f   .....: ugra_tic_
0060   74 61 63 5f 72 65 76 65 72 73 65 5f 74 61 6b 65   tac_reverse_take
0070   73 5f 74 69 6d 65 5f 32 31 30 37 63 33 65 30 34   s_time_2107c3e04
0080   62 33 62                                          b3b
```

Раскодируем его:

```
Подарочный код на другие игры нашей компании: ugra_tic_tac_reverse_takes_time_2107c3e04b3b
```

Флаг: **ugra_tic_tac_reverse_takes_time_2107c3e04b3b**
